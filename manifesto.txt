Muffin // Multi-functional verificator and analyzer

Model checking is hard to apply outside of academia and specialized fields, because the tools are hard to understand, slow to adapt and in general complicated. Complexity is not a bad thing, however, it introduces a steep learning curve to potential users.

Muffin aims to soften the learning curve by focusing on reusability, multi-core performance and good tool support. Secondary goal of Muffin initiative is to explore possible usages of model checking in less technical areas, such as UI/UX design, interaction testing, etc.

Muffin initiative has three phases:

Phase I: Incubation.

The point of this phase is to explore existing model checking tools and fields of application. In this phase, modules would be developed to mimick the existing tools while maintaining or increasing their performance and splitting the functionality into small, self contained libraries.

The challenge of this phase is to design efficient multicore/GPU implementations that will outperform existing tools.

Optional challenge of this phase is to come up with a formalism that would allow synthesis of systems based on components that exhibit potential for bad behavior (Generating counter examples for libraries) and reuse of model checking examples in case of reusable components.

The end of this phase should be marked by raising awareness of Muffin in the scientific community with publications and contest submissions.

Phase II: Outbreak.

Phase II should take and apply existing muffin algorithms to real world languages and problems. This will consist of designing various preprocessor, translator and visualisation tools with supporting infrastructure (IDE plugins, web tools, build server integrations).

The challenge of this phase is to design appropriate abstractions that will maintain correctness while reducing the state space of actual programs so that they can be verified by existing algorithms.

It should also represent the peak of new field exploration for formal process/system analysis.

The end of this phase should be marked by raising awerness in the small/medium developer community such as Java/.NET/Android/iOS/web developers and general open source community.

Phase III: Take-over.

Phase III focuses on maintaining the overall tool and it's components while introducing them to broader, corporate audience. More complex, distributed and learning algorithms should be developed to facilitate verification of complex applications.

Challenge of this phase is to scale the tools to appropriate complexity levels while maintaining ease of use.

The end of this phase should be marked by having a self sustaining company that will further push boundries of Muffin initiative.


Technological manifesto:
In order to avoid technological dept, tools should be developed with focus on maintainability and speed of development while maintaining high performance.

The Muffin framework should consist of high number of small, simple, algorithm-oriented command line utilities that can be developed in parallel.

To this end, we propose a Tick-Tock software development process for the core algorithms:

The Tick phase: New algorithm or extension of existing algorithm is implemented in one of the high level languages (JVM/.NET), ensuring extensibility and ease of development. In this phase, architectural and conceptual changes can be appliet to the algorithm at any time. At the end of the phase, there should be a set of presentable use cases that are either not solvable by existing algorithms or that represent a considerable performance improvement (and there is a decision procedure that identifies these use cases). Algorithms in the Tick phase are presented as experimential.

The Tock phase: The algorithm is implemented in one of the low level languages (Rust/Go) and is tuned for optimal performance (inter-compilation, SSE, specialized implementations for concrete input classes...). The algorithm is frozen and should not be changed/extended. Only changes that are performance oriented are allowed. Algorithms in the Tock phase are presented as stable.

GPU Algorithms: Special case are GPU Algorithms. For these cases the Tick phase consists of writing algorithms that are as reusable as possible (OpenCL) while the Tock phase serves for architecture/hw specific optimisations, such as rewrite into CUDA or special latest features.

All tools should evolve in a tick-tock manner, however the length/periodicity of the cycle is not strict. Some tools might undergo several cycles while others might be replaced by other tools after one cycle. Finally, some tools won't even make it past the initial Tick phase.

Roadmap:

Summer 2016:
LTS explicit and symbolic verification tools (Petri nets, Boolean networks, Hardware). CTL, LTL, Reachability.
Tapaal, Divine, NuSMV, Marcie.

Winter 2016:
JVM bytecode translators and general java verification.
